---
description: 在封存前驗證實作是否符合變更 artifacts
---

驗證實作是否符合變更 artifacts（specs、tasks、design）。

**輸入**：可在 `/opsx:verify` 後選配指定變更名稱（例如 `/opsx:verify add-auth`）。如果省略，請檢查是否可以從對話內容中推斷。如果模糊不清或不明確，您必須提示使用者選擇可用的變更。

**步驟**

1. **如果未提供變更名稱，提示進行選擇**

   執行 `openspec list --json` 以取得可用的變更。使用 **AskUserQuestion 工具** 讓使用者選擇。

   僅顯示具有實作任務（tasks artifact 已存在）的變更。
   如果可用，請包含每個變更所使用的 schema。
   將任務未完成的變更標記為「（進行中）」。

   **重要**：請勿猜測或自動選擇變更。務必讓使用者選擇。

2. **檢查狀態以瞭解 schema**
   ```bash
   openspec status --change "<name>" --json
   ```
   解析 JSON 以瞭解：
   - `schemaName`：正在使用的工作流（例如 "spec-driven"）
   - 此變更存在哪些 artifacts

3. **取得變更目錄並載入 artifacts**

   ```bash
   openspec instructions apply --change "<name>" --json
   ```

   這會回傳變更目錄與內容檔案。從 `contextFiles` 讀取所有可用的 artifacts。

4. **初始化驗證報告結構**

   建立具有三個面向的報告結構：
   - **完整性 (Completeness)**：追蹤任務與 spec 涵蓋範圍
   - **正確性 (Correctness)**：追蹤需求實作與情境涵蓋範圍
   - **連貫性 (Coherence)**：追蹤設計遵循情況與模式一致性

   每個面向都可以有 CRITICAL、WARNING 或 SUGGESTION 等級的問題。

5. **驗證完整性 (Completeness)**

   **任務完成情況**：
   - 如果 `contextFiles` 中存在 `tasks.md`，請讀取它
   - 解析核取方塊：`- [ ]`（未完成）與 `- [x]`（已完成）
   - 計算已完成任務與總任務數
   - 如果存在未完成的任務：
     - 為每個未完成任務新增一個 CRITICAL 問題
     - 建議：「完成任務：<描述>」或「如果已實作，請標記為完成」

   **Spec 涵蓋範圍**：
   - 如果 `openspec/changes/<name>/specs/` 中存在 delta specs：
     - 提取所有需求（標記為 "### Requirement:"）
     - 針對每個需求：
       - 在程式碼庫中搜尋與該需求相關的關鍵字
       - 評估實作是否可能已存在
     - 如果需求似乎未實作：
       - 新增 CRITICAL 問題：「找不到需求：<需求名稱>」
       - 建議：「實作需求 X：<描述>」

6. **驗證正確性 (Correctness)**

   **需求實作對照**：
   - 針對 delta specs 中的每個需求：
     - 在程式碼庫中搜尋實作證據
     - 如果找到，註記檔案路徑與行號範圍
     - 評估實作是否符合需求意圖
     - 如果偵測到偏差：
       - 新增 WARNING：「實作可能與 spec 有偏差：<詳細資訊>」
       - 建議：「對照需求 X 檢閱 <檔案>:<行號>」

   **情境涵蓋範圍**：
   - 針對 delta specs 中的每個情境（標記為 "#### Scenario:"）：
     - 檢查程式碼中是否處理了相關條件
     - 檢查是否存在涵蓋該情境的測試
     - 如果情境似乎未被涵蓋：
       - 新增 WARNING：「情境未涵蓋：<情境名稱>」
       - 建議：「為情境新增測試或實作：<描述>」

7. **驗證連貫性 (Coherence)**

   **設計遵循情況**：
   - 如果 `contextFiles` 中存在 `design.md`：
     - 提取關鍵決策（尋找諸如 "Decision:"、"Approach:"、"Architecture:" 的章節）
     - 驗證實作是否遵循這些決策
     - 如果偵測到矛盾：
       - 新增 WARNING：「未遵循設計決策：<決策>」
       - 建議：「更新實作或修改 `design.md` 以符合實際情況」
   - 如果沒有 `design.md`：跳過設計遵循情況檢查，註記「無 `design.md` 可供驗證」

   **程式碼模式一致性**：
   - 檢閱新程式碼是否與專案模式一致
   - 檢查檔案命名、目錄結構、編碼風格
   - 如果發現重大偏差：
     - 新增 SUGGESTION：「程式碼模式偏差：<詳細資訊>」
     - 建議：「考慮遵循專案模式：<範例>」

8. **產生驗證報告**

   **摘要計分板**：
   ```
   ## 驗證報告：<change-name>

   ### 摘要
   | 面向         | 狀態              |
   |--------------|------------------|
   | 完整性       | X/Y 任務，N 個需求 |
   | 正確性       | M/N 個需求已涵蓋   |
   | 連貫性       | 已遵循/有問題      |
   ```

   **依優先級排序的問題**：

   1. **CRITICAL**（封存前必須修正）：
      - 未完成的任務
      - 缺失的需求實作
      - 每一項皆附帶具體且可執行的建議

   2. **WARNING**（應該修正）：
      - Spec/設計偏差
      - 缺失的情境涵蓋
      - 每一項皆附帶具體建議

   3. **SUGGESTION**（建議修正）：
      - 模式不一致
      - 細微改進
      - 每一項皆附帶具體建議

   **最終評估**：
   - 如果有 CRITICAL 問題：「發現 X 個關鍵問題。封存前請先修正。」
   - 如果僅有警告：「無關鍵問題。有 Y 個警告供參考。已可封存（附帶所述的改進建議）。」
   - 如果全部通過：「所有檢查皆已通過。已可封存。」

**驗證啟發式方法**

- **完整性 (Completeness)**：專注於客觀的檢查清單項目（核取方塊、需求列表）
- **正確性 (Correctness)**：使用關鍵字搜尋、檔案路徑分析、合理的推斷——不要求絕對確定
- **連貫性 (Coherence)**：尋找明顯的不一致之處，不要吹毛求疵
- **偽陽性**：當不確定時，優先選擇 SUGGESTION 而非 WARNING，優先選擇 WARNING 而非 CRITICAL
- **可執行性**：每個問題都必須包含具備檔案/行號引用的具體建議（如果適用）

**優雅降級**

- 如果僅存在 `tasks.md`：僅驗證任務完成情況，跳過 spec/設計檢查
- 如果同時存在任務與 specs：驗證完整性與正確性，跳過設計
- 如果具有完整的 artifacts：驗證所有三個面向
- 務必註記哪些檢查被跳過以及原因

**輸出格式**

使用清晰的 Markdown 並包含：
- 摘要計分板表格
- 按優先級分組的問題列表 (CRITICAL/WARNING/SUGGESTION)
- 格式為 `file.ts:123` 的程式碼引用
- 具體、可執行的建議
- 不要使用諸如「考慮檢閱」之類模糊的建議
