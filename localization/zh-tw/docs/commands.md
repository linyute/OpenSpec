# 指令

這是 OpenSpec 斜線指令的參考文件。這些指令在您的 AI 程式碼助理聊天介面（例如 Claude Code、Cursor、Windsurf）中呼叫。

有關工作流程模式以及何時使用每個指令，請參閱 [工作流程](workflows.md)。有關 CLI 指令，請參閱 [CLI](cli.md)。

## 快速參考

| 指令 | 用途 |
|---------|---------|
| `/opsx:explore` | 在投入變更之前思考想法 |
| `/opsx:new` | 開始一個新的變更 |
| `/opsx:continue` | 根據相依性建立下一個成品 |
| `/opsx:ff` | 快進：一次建立所有規劃成品 |
| `/opsx:apply` | 實作來自變更的任務 |
| `/opsx:verify` | 驗證實作是否符合成品 |
| `/opsx:sync` | 將差異規格合併到主規格中 |
| `/opsx:archive` | 封存已完成的變更 |
| `/opsx:bulk-archive` | 一次封存多個變更 |
| `/opsx:onboard` | 引導式教學，帶領您完成完整的工作流程 |

---

## 指令參考

### `/opsx:explore`

在投入變更之前思考想法、調查問題並釐清需求。

**語法：**
```
/opsx:explore [topic]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `topic` | 否 | 您想要探索或調查的主題 |

**它的作用：**
- 開啟一個不需要特定結構的探索性對話
- 調查程式碼庫以回答問題
- 比較不同的選項和方法
- 建立視覺圖表以釐清思路
- 當想法具體化時可以過渡到 `/opsx:new`

**範例：**
```text
您：/opsx:explore

AI： 您想要探索什麼？

您： 我們應該如何處理行動應用程式的身份驗證？

AI： 讓我調查一下您目前的驗證設定...
     [分析程式碼庫]

     我看到您在網頁應用程式中使用基於工作階段的驗證。
     對於行動裝置，我們有三個主要選項：

     1. JWT token (無狀態，支援離線工作)
     2. OAuth2 (如果您需要第三方登入)
     3. 擴充目前的工作階段 (較簡單，但需要連線)

     您的 API 已經設定了 CORS。您對哪個方向感興趣？

您： 我們用 JWT 吧。我們可以為此開始一個變更嗎？

AI： 隨時待命。執行 /opsx:new add-jwt-auth 即可開始。
```

**提示：**
- 當需求不明確或需要調查時使用
- 探索期間不會建立任何成品
- 適合在決定之前比較多種方法
- 可以讀取檔案並搜尋程式碼庫

---

### `/opsx:new`

開始一個新的變更。建立變更資料夾結構並使用選定的 schema 進行建構。

**語法：**
```
/opsx:new [change-name] [--schema <schema-name>]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-name` | 否 | 變更資料夾的名稱 (如果未提供則會提示) |
| `--schema` | 否 | 要使用的工作流程 schema (預設：來自設定或 `spec-driven`) |

**它的作用：**
- 建立 `openspec/changes/<change-name>/` 目錄
- 在變更資料夾中建立 `.openspec.yaml` Metadata 檔案
- 顯示準備好建立的第一個成品範本
- 如果未提供，則提示輸入變更名稱和 schema

**建立的內容：**
```
openspec/changes/<change-name>/
└── .openspec.yaml    # 變更 Metadata (schema, 建立日期)
```

**範例：**
```
您：/opsx:new add-dark-mode

AI： 已建立 openspec/changes/add-dark-mode/
     Schema：spec-driven

     準備好建立：proposal
     使用 /opsx:continue 來建立它，或使用 /opsx:ff 來建立所有成品。
```

**帶有 schema 的範例：**
```
您：/opsx:new write-tests --schema tdd

AI： 已建立 openspec/changes/write-tests/
     Schema：tdd

     準備好建立：spec
```

**提示：**
- 使用具描述性的名稱：`add-feature`、`fix-bug`、`refactor-module`
- 避免使用通用的名稱，如 `update`、`changes`、`wip`
- Schema 也可以在專案設定 (`openspec/config.yaml`) 中設定

---

### `/opsx:continue`

建立相依鏈中的下一個成品。一次建立一個成品以實現漸進式進展。

**語法：**
```
/opsx:continue [change-name]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-name` | 否 | 要繼續哪個變更 (如果未提供，則從內容推斷) |

**它的作用：**
- 查詢成品相依性圖表
- 顯示哪些成品已就緒與哪些已被封鎖
- 建立第一個就緒的成品
- 讀取相依檔案以獲取內容
- 顯示建立後哪些內容變得可用

**範例：**
```
您：/opsx:continue

AI： 變更：add-dark-mode

     成品狀態：
     ✓ proposal    (完成)
     ◆ specs       (就緒)
     ◆ design      (就緒)
     ○ tasks       (已封鎖 - 需要：specs)

     正在建立 specs...

     [讀取 proposal.md，根據需求建立規格]

     ✓ 已建立 openspec/changes/add-dark-mode/specs/ui/spec.md

     現在可用：tasks
     執行 /opsx:continue 以建立下一個成品。
```

**提示：**
- 當您想在繼續之前檢視每個成品時使用
- 適用於您想要控制的複雜變更
- 多個成品可能會同時變得就緒
- 您可以在繼續之前編輯已建立的成品

---

### `/opsx:ff`

快進成品建立。一次建立所有規劃成品。

**語法：**
```
/opsx:ff [change-name]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-name` | 否 | 要快進哪個變更 (如果未提供，則從內容推斷) |

**它的作用：**
- 按相依順序建立所有成品
- 透過待辦清單追蹤進度
- 當所有 `apply-required` 成品完成時停止
- 在建立下一個成品之前讀取每個相依項

**範例：**
```
您：/opsx:ff add-dark-mode

AI： 正在快進 add-dark-mode...

     ✓ 正在建立 proposal.md
     ✓ 正在建立 specs/ui/spec.md
     ✓ 正在建立 design.md
     ✓ 正在建立 tasks.md

     所有規劃成品已完成！
     準備好進行實作。執行 /opsx:apply 即可開始。
```

**提示：**
- 當您對要建構的內容有清晰的了解時使用
- 對於簡單的變更，比 `/opsx:continue` 更快
- 您稍後仍然可以編輯成品
- 適合小型到中型功能

---

### `/opsx:apply`

實作來自變更的任務。處理任務清單，撰寫程式碼並勾選項目。

**語法：**
```
/opsx:apply [change-name]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-name` | 否 | 要實作哪個變更 (如果未提供，則從內容推斷) |

**它的作用：**
- 讀取 `tasks.md` 並識別未完成的任務
- 一個接一個地處理任務
- 根據需要撰寫程式碼、建立檔案、執行測試
- 使用複選框 `[x]` 將任務標記為完成

**範例：**
```
您：/opsx:apply

AI： 正在實作 add-dark-mode...

     正在讀取 tasks.md：
     - [ ] 1.1 建立 ThemeContext
     - [ ] 1.2 新增 CSS 自訂屬性
     - [ ] 1.3 實作 localStorage 持久化

     正在處理 1.1：建立 ThemeContext...
     [建立 src/context/ThemeContext.tsx]

     ✓ 1.1 完成

     正在處理 1.2：新增 CSS 自訂屬性...
     [更新 src/styles/globals.css]

     ✓ 1.2 完成
     ...
```

**提示：**
- 如果中斷，可以從上次停下的地方恢復
- 透過指定變更名稱來用於平行變更
- 完成狀態會在 `tasks.md` 的複選框中追蹤

---

### `/opsx:verify`

驗證實作是否符合您的變更成品。檢查完整性、正確性和一致性。

**語法：**
```
/opsx:verify [change-name]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-name` | 否 | 要驗證哪個變更 (如果未提供，則從內容推斷) |

**它的作用：**
- 檢查實作品質的三個面向
- 搜尋程式碼庫以尋找實作證據
- 報告分類為「嚴重 (CRITICAL)」、「警告 (WARNING)」或「建議 (SUGGESTION)」的問題
- 不會封鎖封 archive，但會顯現問題

**驗證面向：**

| 面向 | 驗證內容 |
|-----------|-------------------|
| **完整性** | 所有任務已完成、所有需求已實作、情境涵蓋範圍 |
| **正確性** | 實作符合規格意圖、已處理邊緣情況 |
| **一致性** | 設計決策反映在程式碼中、模式一致 |

**範例：**
```
您：/opsx:verify

AI： 正在驗證 add-dark-mode...

     完整性
     ✓ tasks.md 中的所有 8 個任務均已勾選
     ✓ 規格中的所有需求都有對應的程式碼
     ⚠ 情境 "System preference detection" 沒有測試涵蓋範圍

     正確性
     ✓ 實作符合規格意圖
     ✓ 已處理情境中的邊緣情況
     ✓ 錯誤狀態符合規格定義

     一致性
     ✓ 設計決策反映在程式碼結構中
     ✓ 命名慣例與 design.md 一致
     ⚠ 設計中提到 "CSS variables" 但實作使用了 Tailwind 類別

     摘要
     ─────────────────────────────
     嚴重問題：0
     警告：2
     準備好封存：是 (帶有警告)

     建議：
     1. 為系統偏好偵測新增測試
     2. 更新 design.md 以反映 Tailwind 的使用，或重構以使用 CSS 變數
```

**提示：**
- 在封存之前執行以儘早發現不匹配的地方
- 警告不會封鎖封存，但表示潛在問題
- 適合在提交之前檢視 AI 的工作
- 可以揭示成品與實作之間的偏差

---

### `/opsx:sync`

**選用指令。** 將來自變更的差異規格合併到主規格中。封存時會提示是否需要同步，因此您通常不需要手動執行此指令。

**語法：**
```
/opsx:sync [change-name]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-name` | 否 | 要同步哪個變更 (如果未提供，則從內容推斷) |

**它的作用：**
- 從變更資料夾讀取差異規格
- 剖析「新增 (ADDED)」、「修改 (MODIFIED)」、「移除 (REMOVED)」、「重新命名 (RENAMED)」章節
- 將變更合併到主 `openspec/specs/` 目錄
- 保留差異中未提到的現有內容
- 不會封存變更 (保持作用中)

**範例：**
```text
您：/opsx:sync

AI： 正在同步 add-dark-mode 差異規格...

     正在讀取：openspec/changes/add-dark-mode/specs/ui/spec.md
     目標：  openspec/specs/ui/spec.md

     要套用的變更：
     ✓ 新增：主題選擇需求 (2 個情境)
     ✓ 新增：無障礙需求 (1 個情境)

     正在合併...
     ✓ openspec/specs/ui/spec.md 已更新

     變更保持作用中。準備就緒後執行 /opsx:archive 以完成。
```

**何時手動使用：**

| 情境 | 是否使用同步？ |
|----------|-----------|
| 長期進行的變更，希望在封存前將規格納入主規格 | 是 |
| 多個平行變更需要更新後的基礎規格 | 是 |
| 想要單獨預覽/檢閱合併結果 | 是 |
| 快速變更，直接進行封存 | 否 (封存會處理它) |

**提示：**
- 同步是智慧型的，不是複製貼上
- 可以向現有需求新增情境而不會重複
- 同步後變更仍保持作用中 (未封存)
- 大多數使用者永遠不需要直接呼叫此指令——封存會在需要時提示

---

### `/opsx:archive`

封存已完成的變更。完成變更並將其移動到封存資料夾。

**語法：**
```
/opsx:archive [change-name]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-name` | 否 | 要封存哪個變更 (如果未提供，則從內容推斷) |

**它的作用：**
- 檢查成品完成狀態
- 檢查任務完成情況 (如果未完成則發出警告)
- 如果尚未同步，則提議同步差異規格
- 將變更資料夾移動到 `openspec/changes/archive/YYYY-MM-DD-<name>/`
- 保留所有成品以供稽核追蹤

**範例：**
```text
您：/opsx:archive

AI： 正在封存 add-dark-mode...

     成品狀態：
     ✓ proposal.md 已存在
     ✓ specs/ 已存在
     ✓ design.md 已存在
     ✓ tasks.md 已存在 (8/8 個任務已完成)

     差異規格：尚未同步
     → 立即同步？ (建議)

您： 是

AI： ✓ 已同步規格到 openspec/specs/ui/spec.md
     ✓ 已移動到 openspec/changes/archive/2025-01-24-add-dark-mode/

     變更封存成功。
```

**提示：**
- 封存不會因任務未完成而封鎖，但會發出警告
- 差異規格可以在封存期間或之前同步
- 封存的變更會保留在歷史記錄中
- 先使用 `/opsx:verify` 以發現問題

---

### `/opsx:bulk-archive`

一次封存多個已完成的變更。處理變更之間的規格衝突。

**語法：**
```
/opsx:bulk-archive [change-names...]
```

**引數：**
| 引數 | 必填 | 說明 |
|----------|----------|-------------|
| `change-names` | 否 | 要封存的特定變更 (如果未提供，則提示選擇) |

**它的作用：**
- 列出所有已完成的變更
- 在封存之前驗證每個變更
- 偵測跨變更的規格衝突
- 透過檢查實際實作的內容來解決衝突
- 按時間順序封存

**範例：**
```
您：/opsx:bulk-archive

AI： 找到 3 個已完成的變更：
     - add-dark-mode (8/8 個任務已完成)
     - fix-login-bug (3/3 個任務已完成)
     - update-footer (2/2 個任務已完成)

     正在檢查規格衝突...
     ⚠ add-dark-mode 和 update-footer 均修改了 specs/ui/

     正在檢查程式碼庫以解決...
     兩個變更皆已實作。將按時間順序合併：
     1. add-dark-mode (建立於 1 月 20 日)
     2. update-footer (建立於 1 月 22 日)

     封存所有 3 個變更？

您： 是

AI： ✓ 已封存 add-dark-mode
     ✓ 已封存 fix-login-bug
     ✓ 已封存 update-footer
     規格已合併：add-dark-mode → update-footer
```

**提示：**
- 適合平行工作流
- 衝突解決是代理式的 (檢查程式碼庫)
- 變更按建立順序封存
- 在覆寫規格內容之前會提示

---

### `/opsx:onboard`

引導式導覽完整 OpenSpec 工作流程。一個使用您實際程式碼庫的互動式教學。

**語法：**
```
/opsx:onboard
```

**它的作用：**
- 透過敘述帶領您完成一個完整的工作流程週期
- 掃描您的程式碼庫以尋找真正的改進機會
- 使用真實成品建立實際變更
- 實作實際工作 (小型、安全的變更)
- 封存已完成的變更
- 在每一步驟發生時解釋它

**階段：**
1. 歡迎與程式碼庫分析
2. 尋找改進機會
3. 建立變更 (`/opsx:new`)
4. 撰寫提案
5. 建立規格
6. 撰寫設計
7. 建立任務
8. 實作任務 (`/opsx:apply`)
9. 驗證實作
10. 封存變更
11. 摘要與後續步驟

**範例：**
```
您：/opsx:onboard

AI： 歡迎來到 OpenSpec！

     我將使用您實際的程式碼庫帶領您完成完整的工作流程。
     我們將尋找一些可以改進的小地方，為其建立適當的變更，
     實作它並將其封存。

     讓我掃描您的程式碼庫以尋找機會...

     [分析程式碼庫]

     我發現了一些我們可以處理的事情：
     1. 為聯絡表單新增輸入驗證
     2. 改進驗證流程中的錯誤訊息
     3. 為非同步按鈕新增載入狀態

     您對哪個感興趣？ (或提議其他內容)
```

**提示：**
- 最適合學習工作流程的新使用者
- 使用真實程式碼，而非玩具範例
- 建立您可以保留或捨棄的真實變更
- 完成大約需要 15-30 分鐘

---

## 各 AI 工具的指令語法

不同的 AI 工具使用的指令語法略有不同。請使用符合您工具的格式：

| 工具 | 語法範例 |
|------|----------------|
| Claude Code | `/opsx:new`, `/opsx:apply` |
| Cursor | `/opsx-new`, `/opsx-apply` |
| Windsurf | `/opsx-new`, `/opsx-apply` |
| Copilot | `/opsx-new`, `/opsx-apply` |

無論語法如何，功能都是相同的。

---

## 舊版指令

這些指令使用舊的「一次性 (all-at-once)」工作流程。它們仍然有效，但建議使用 OPSX 指令。

| 指令 | 它的作用 |
|---------|--------------|
| `/openspec:proposal` | 一次建立所有成品 (提案、規格、設計、任務) |
| `/openspec:apply` | 實作變更 |
| `/openspec:archive` | 封存變更 |

**何時使用舊版指令：**
- 使用舊工作流程的現有專案
- 您不需要增量成品建立的簡單變更
- 偏好「全有或全無」方法

**遷移到 OPSX：**
舊版變更可以使用 OPSX 指令繼續進行。成品結構是相容的。

---

## 疑難排解

### 「找不到變更 (Change not found)」

指令無法識別要處理哪個變更。

**解決方案：**
- 明確指定變更名稱：`/opsx:apply add-dark-mode`
- 檢查變更資料夾是否存在：`openspec list`
- 確認您位於正確的專案目錄中

### 「沒有就緒的成品 (No artifacts ready)」

所有成品要麼已完成，要麼因缺少相依性而被封鎖。

**解決方案：**
- 執行 `openspec status --change <name>` 以查看是什麼在封鎖
- 檢查所需的成品是否存在
- 先建立缺失的相依成品

### 「找不到 Schema (Schema not found)」

指定的 schema 不存在。

**解決方案：**
- 列出可用的 schema：`openspec schemas`
- 檢查 schema 名稱的拼字
- 如果是自訂 schema，請建立它：`openspec schema init <name>`

### 指令無法辨識

AI 工具無法辨識 OpenSpec 指令。

**解決方案：**
- 確保 OpenSpec 已初始化：`openspec init`
- 重新產生技能：`openspec update`
- 檢查 `.claude/skills/` 目錄是否存在 (對於 Claude Code)
- 重新啟動您的 AI 工具以載入新技能

### 成品產生不正確

AI 建立了不完整或不正確的成品。

**解決方案：**
- 在 `openspec/config.yaml` 中新增專案背景資訊
- 為特定引導新增各成品規則
- 在您的變更說明中提供更多細節
- 使用 `/opsx:continue` 而不是 `/opsx:ff` 以獲得更多控制

---

## 後續步驟

- [工作流程](workflows.md) - 常見模式以及何時使用各個指令
- [CLI](cli.md) - 用於管理和驗證的終端機指令
- [自訂](customization.md) - 建立自訂 schema 和工作流程
