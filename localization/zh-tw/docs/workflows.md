# 工作流程

本指南涵蓋了 OpenSpec 常見的工作流程模式以及何時使用各個模式。有關基本設定，請參閱 [入門指南](getting-started.md)。有關指令參考，請參閱 [指令](commands.md)。

## 理念：動作而非階段

傳統的工作流程強制您經歷各個階段：規劃、實作、然後完成。但實際工作並非總是能整齊地放入這些框框中。

OPSX 採取了不同的方法：

```text
傳統 (階段鎖定)：

  規劃 ────────► 實作 ────────► 完成
    │             │
    │ 「無法回頭」  │
    └─────────────┘

OPSX (流動動作)：

  提案 ──► 規格 ──► 設計 ──► 任務 ──► 實作
```

**關鍵原則：**

- **動作而非階段** - 指令是您可以做的事情，而不是您被困在其中的階段
- **相依性是推動因素** - 它們顯示可以做什麼，而不是接下來必須做什麼

> **自訂：** OPSX 工作流程由定義成品順序的 schema 驅動。有關建立自訂 schema 的詳細資訊，請參閱 [自訂](customization.md)。

## 工作流程模式

### 快速開發功能

當您知道要建構什麼並只需要執行時：

```text
/opsx:new ──► /opsx:ff ──► /opsx:apply ──► /opsx:verify ──► /opsx:archive
```

**範例對話：**

```text
您：/opsx:new add-logout-button

AI： 已建立 openspec/changes/add-logout-button/
     準備好建立：proposal

您：/opsx:ff

AI： 正在建立所有規劃成品...
     ✓ proposal.md
     ✓ specs/
     ✓ design.md
     ✓ tasks.md
     準備好實作！

您：/opsx:apply

AI： 正在處理任務...
     ✓ 在頁首新增了登出按鈕
     ✓ 實作了工作階段清除
     ✓ 新增了確認對話方塊
     所有任務已完成！

您：/opsx:archive

AI： ✓ 已合併規格
     ✓ 已封存變更
```

**最適合：** 小型到中型功能、錯誤修復、簡單明瞭的變更。

### 探索性開發

當需求不明確或您需要先進行調查時：

```text
/opsx:explore ──► /opsx:new ──► /opsx:continue ──► ... ──► /opsx:apply
```

**範例對話：**

```text
您：/opsx:explore

AI： 您想要探索什麼？

您： 我想提高頁面載入效能，但不確定瓶頸在哪裡。

AI： 讓我協助調查...
     [分析套件大小、識別慢速查詢、檢閱元件渲染模式]

     我發現了三個主要瓶頸：
     1. 未經優化的大型圖片
     2. ProductList 中的同步資料擷取
     3. Context 變更導致的重新渲染

     您想先處理哪一個？

您： 我們來處理資料擷取問題吧。

您： /opsx:new optimize-product-list-fetching

AI： 已建立變更。準備好建立：proposal

您： /opsx:continue

AI： 根據我們的探索建立提案...
     [撰寫包含調查洞察的提案]

     準備好建立：specs, design
     您接下來想要建立哪一個？

您： /opsx:continue

AI： 正在建立規格...
```

**最適合：** 效能優化、偵錯、架構決策、需求不明確的情況。

### 平行變更

同時處理多個變更：

```text
變更 A：/opsx:new ──► /opsx:ff ──► /opsx:apply (進行中)
                                         │
                                      內容切換
                                         │
變更 B：/opsx:new ──► /opsx:ff ──────► /opsx:apply
```

**範例對話：**

```text
您： 我正在處理 add-dark-mode，但被拉去修復一個錯誤

您： /opsx:new fix-login-redirect

AI： 已建立 openspec/changes/fix-login-redirect/

您： /opsx:ff

AI： ✓ 已建立規劃成品

您： /opsx:apply

AI： 正在處理 fix-login-redirect...
     [實作修復]
     所有任務已完成！

您： /opsx:archive

AI： ✓ 已封存 fix-login-redirect

您： 讓我們回到深色模式吧

您： /opsx:apply add-dark-mode

AI： 正在恢復 add-dark-mode...
     從任務 2.3 開始：更新 Header...
```

**最適合：** 平行工作流、緊急中斷、團隊協作。

當您有多個已完成的變更時，使用 `/opsx:bulk-archive`：

```text
您： /opsx:bulk-archive

AI： 找到 3 個已完成的變更：
     - add-dark-mode (所有任務已完成)
     - fix-login-redirect (所有任務已完成)
     - update-footer (所有任務已完成)

     正在檢查規格衝突...
     ⚠ add-dark-mode 和 update-footer 均修改了 specs/ui/

     正在檢查程式碼庫以解決...
     兩個變更皆已實作。將按時間順序套用。

     封存所有 3 個變更？

您： 是

AI： ✓ 已封存 add-dark-mode
     ✓ 已封存 fix-login-redirect
     ✓ 已封存 update-footer
     規格已按順序合併：add-dark-mode → update-footer
```

批次封存會偵測多個變更何時觸及相同的規格，並透過檢查實際實作的內容來解決衝突。

### 完成一個變更

建議的完成流程：

```text
/opsx:apply ──► /opsx:verify ──► /opsx:archive
                    │                 │
                 驗證實作           如果需要則
                                   提示同步
```

#### 驗證：檢查您的工作

`/opsx:verify` 從三個面向驗證實作是否符合您的成品：

```text
您：/opsx:verify

AI： 正在驗證 add-auth...

     完整性
     ✓ tasks.md 中的所有 12 個任務均已勾選
     ✓ 規格中的所有需求都有對應的程式碼
     ⚠ 情境 "Session timeout after inactivity" 未經測試

     正確性
     ✓ 實作符合規格意圖
     ✓ 已處理情境中的邊緣情況
     ✓ 錯誤狀態符合規格定義

     一致性
     ✓ 設計決策反映在程式碼結構中
     ✓ 命名慣例與 design.md 一致
     ⚠ 設計中提到 "event-driven" 但實作使用了輪詢 (polling)

     摘要
     ─────────────────────────────
     嚴重問題：0
     警告：2
     準備好封存：是 (帶有警告)

     建議：
     1. 為工作階段逾時情境新增測試
     2. 考慮按照設計重構為事件驅動，或更新 design.md
```

**驗證檢查的內容：**

| 面向   | 驗證內容                                     |
| ------ | -------------------------------------------- |
| 完整性 | 所有任務已完成、所有需求已實作、情境涵蓋範圍 |
| 正確性 | 實作符合規格意圖、已處理邊緣情況             |
| 一致性 | 設計決策反映在程式碼中、模式一致             |

驗證不會封鎖封存，但它會顯現您可能想要先處理的問題。

#### 封存：完成變更

`/opsx:archive` 完成變更並將其移動到封存：

```text
您：/opsx:archive

AI： 正在封存 add-auth...

     成品狀態：
     ✓ proposal.md 已存在
     ✓ specs/ 已存在
     ✓ design.md 已存在
     ✓ tasks.md 已存在 (12/12 個任務已完成)

     差異規格：尚未同步到主規格
     → 立即同步？

您： 是

AI： ✓ 已同步規格到 openspec/specs/auth/spec.md
     ✓ 已移動到 openspec/changes/archive/2025-01-24-add-auth/

     變更封存成功。
```

如果規格未同步，封存會發出提示。它不會因為任務未完成而封鎖，但會向您發出警告。

## 何時使用什麼

### `/opsx:ff` vs `/opsx:continue`

| 情況                     | 使用             |
| ------------------------ | ---------------- |
| 需求清晰，準備好建構     | `/opsx:ff`       |
| 探索中，想要檢視每一步   | `/opsx:continue` |
| 想要在規格前疊代提案     | `/opsx:continue` |
| 時間緊迫，需要快速行動   | `/opsx:ff`       |
| 複雜變更，想要掌握主控權 | `/opsx:continue` |

**經驗法則：** 如果您可以預先描述完整範圍，請使用 `/opsx:ff`。如果您是在過程中逐步摸索，請使用 `/opsx:continue`。

### 何時更新 vs 重新開始

一個常見的問題：何時可以更新現有的變更，何時應該開始一個新的變更？

**在以下情況更新現有變更：**

- 相同的意圖，精煉的執行
- 範圍縮小（先發布 MVP，其餘稍後處理）
- 學習驅動的修正（程式碼庫與您的預期不符）
- 根據實作發現進行設計微調

**在以下情況建立新變更：**

- 意圖發生根本變化
- 範圍爆炸到完全不同的工作
- 原始變更可以獨立標記為「完成」
- 修補程式會讓事情更混亂而非清晰

```text
                ┌──────────────────────────────────────┐
                │           這是同樣的工作嗎？            │
                └──────────────────┬───────────────────┘
                                   │
                ┌──────────────────┼──────────────────┐
                │                  │                  │
                ▼                  ▼                  ▼
              意圖相同？        >50% 重疊？        原始變更在
              問題相同？        範圍相同？         沒有這些變更
                │                  │          下可以「完成」嗎？
                │                  │                  │
       ┌────────┴────────┐  ┌──────┴──────┐   ┌───────┴───────┐
       │                 │  │             │   │               │
       是                否  是            否  否              是
       │                 │  │             │   │               │
       ▼                 ▼  ▼             ▼   ▼               ▼
      更新              新建 更新          新建 更新            新建
```

**範例：「新增深色模式」**

- 「還需要支援自訂主題」 → 新變更（範圍爆炸）
- 「系統偏好偵測比預期困難」 → 更新（意圖相同）
- 「我們先發布切換按鈕，稍後再新增偏好設定」 → 更新後封存，然後建立新變更

## 最佳實踐

### 保持變更專注

每個變更處理一個邏輯工作單元。如果您正在進行「新增功能 X 並重構 Y」，請考慮將其分為兩個獨立的變更。

**為什麼這很重要：**
- 更容易檢閱和理解
- 更乾淨的封存歷史記錄
- 可以獨立發布
- 如果需要，回滾更簡單

### 對於不明確的需求使用 `/opsx:explore`

在投入變更之前，探索問題空間：

```text
您：/opsx:explore

AI： 您想要探索什麼？

您： 我們應該如何處理 API 的速率限制？

AI： 讓我調查您目前的設定和選項...
     [研究程式碼庫，考慮模式]

     我看到我們可以採取三種方法：
     1. 基於中介軟體 (簡單，針對每個端點)
     2. 基於 Redis (可擴充，共用狀態)
     3. 每個使用者的權杖桶 (公平，複雜)

     您目前的技術堆疊建議選擇 #1 或 #2。您的規模如何？
```

探索可以在您建立成品之前釐清思路。

### 封存前進行驗證

使用 `/opsx:verify` 檢查實作是否符合成品：

```text
您：/opsx:verify

AI： 正在驗證 add-dark-mode...

     ✓ tasks.md 中的所有任務均已勾選
     ✓ 規格中的需求有對應的程式碼
     ✓ 設計決策已反映在實作中

     準備好封存！
```

在結束變更之前發現不匹配的地方。

### 清晰命名變更

良好的名稱能讓 `openspec list` 發揮作用：

```text
良好：                          避免：
add-dark-mode                  feature-1
fix-login-redirect             update
optimize-product-query         changes
implement-2fa                  wip
```

## 指令快速參考

有關完整的指令詳細資訊和選項，請參閱 [指令](commands.md)。

| 指令                 | 用途             | 何時使用                  |
| -------------------- | ---------------- | ------------------------- |
| `/opsx:explore`      | 思考想法         | 需求不明確、調查          |
| `/opsx:new`          | 開始一個變更     | 開始任何新工作時          |
| `/opsx:continue`     | 建立下一個成品   | 逐步建立成品              |
| `/opsx:ff`           | 建立所有規劃成品 | 範圍清晰，準備好建構      |
| `/opsx:apply`        | 實作任務         | 準備好撰寫程式碼          |
| `/opsx:verify`       | 驗證實作         | 封存前，發現不匹配        |
| `/opsx:sync`         | 合併差異規格     | 選用 — 封存會在需要時提示 |
| `/opsx:archive`      | 完成變更         | 所有工作已結束            |
| `/opsx:bulk-archive` | 封存多個變更     | 平行工作、批次完成        |

## 後續步驟

- [指令](commands.md) — 帶有選項的完整指令參考
- [核心概念](concepts.md) — 深入探討規格、成品和 schema
- [自訂](customization.md) — 建立自訂工作流程
