# OPSX 工作流程

> 歡迎在 [Discord](https://discord.gg/YctCnvvshC) 提供回饋。

## 這是什麼？

OPSX 現在是 OpenSpec 的標準工作流程。

這是一個針對 OpenSpec 變更的**流動、反覆式工作流程**。不再有僵化的階段 — 只有你可以隨時採取的行動。

## 為什麼存在這個？

舊版的 OpenSpec 工作流程可以運作，但它是**鎖死**的：

- **指示是硬編碼的** — 埋在 TypeScript 中，你無法變更它們
- **全有或全無** — 一個大指令會建立所有內容，無法測試單個部分
- **固定結構** — 每個人都使用相同的工作流程，無法自訂
- **黑盒子** — 當 AI 輸出不佳時，你無法調整提示

**OPSX 開放了這一切。** 現在任何人都可以：

1. **實驗指示** — 編輯模板，看看 AI 是否表現更好
2. **進行精細測試** — 獨立驗證每個成品 (artifact) 的指示
3. **自訂工作流程** — 定義你自己的成品和依賴關係
4. **快速反覆運算** — 變更模板，立即測試，無需重新建構

```
舊版工作流程：                         OPSX：
┌────────────────────────┐           ┌────────────────────────┐
│  硬編碼在套件中          │           │  schema.yaml           │◄── 你編輯這個
│  (無法變更)             │           │  templates/*.md        │◄── 或這個
│        ↓               │           │        ↓               │
│  等待新版本發佈          │           │  立即生效               │
│        ↓               │           │        ↓               │
│  希望它會變得更好        │           │  你自己測試              │
└────────────────────────┘           └────────────────────────┘
```

**這是給每個人的：**
- **團隊** — 建立符合你實際工作方式的工作流程
- **進階使用者** — 調整提示，為你的程式碼庫獲得更好的 AI 輸出
- **OpenSpec 貢獻者** — 在不發佈版本的情況下實驗新方法

我們都還在學習什麼最有效。OPSX 讓我們一起學習。

## 使用者體驗

**線性工作流程的問題：**
你處於「規劃階段」，然後是「實作階段」，最後是「完成」。但實際工作並非如此運算。你實作了一些東西，意識到你的設計錯了，需要更新規格 (specs)，然後繼續實作。線性階段與工作的實際發生方式相衝突。

**OPSX 方法：**
- **是行動，而非階段** — 建立、實作、更新、封存 — 隨時可以執行其中任何一項
- **依賴關係是促成因素** — 它們顯示了什麼是可能的，而不是下一步必須做什麼

```
  提案 (proposal) ──→ 規格 (specs) ──→ 設計 (design) ──→ 任務 (tasks) ──→ 實作 (implement)
```

## 設定

```bash
# 確保你已安裝 openspec — 技能 (skills) 會自動產生
openspec init
```

這會在 `.claude/skills/` (或同等目錄) 中建立 AI 程式碼助理會自動偵測的技能。

在設定過程中，系統會提示你建立一個**專案設定** (`openspec/config.yaml`)。這是選用的，但建議使用。

## 專案設定

專案設定讓你能夠設定預設值，並將專案特定的內容 (context) 注入到所有成品中。

### 建立設定

設定是在 `openspec init` 期間建立的，或者手動建立：

```yaml
# openspec/config.yaml
schema: spec-driven

context: |
  技術棧：TypeScript, React, Node.js
  API 慣例：RESTful, JSON 回應
  測試：單元測試使用 Vitest，e2e 使用 Playwright
  風格：ESLint 搭配 Prettier，嚴格的 TypeScript

rules:
  proposal:
    - 包含回滾計畫
    - 識別受影響的團隊
  specs:
    - 針對情境使用 Given/When/Then 格式
  design:
    - 針對複雜流程包含序列圖
```

### 設定欄位

| 欄位      | 類型   | 描述                                       |
| --------- | ------ | ------------------------------------------ |
| `schema`  | string | 新變更的預設結構描述 (例如：`spec-driven`) |
| `context` | string | 注入到所有成品指示中的專案內容             |
| `rules`   | object | 每個成品的規則，以成品 ID 作為鍵 (key)     |

### 運作方式

**結構描述優先權** (由高至低)：
1. CLI 旗標 (`--schema <名稱>`)
2. 變更 Metadata (變更目錄中的 `.openspec.yaml`)
3. 專案設定 (`openspec/config.yaml`)
4. 預設值 (`spec-driven`)

**內容注入：**
- 內容會附加在每個成品指示的開頭
- 包裝在 `<context>...</context>` 標籤中
- 協助 AI 理解你的專案慣例

**規則注入：**
- 規則僅注入至符合的成品
- 包裝在 `<rules>...</rules>` 標籤中
- 出現在內容之後、模板之前

### 各結構描述的成品 ID

**spec-driven** (預設)：
- `proposal` — 變更提案
- `specs` — 規格
- `design` — 技術設計
- `tasks` — 實作任務

### 設定驗證

- `rules` 中不明的成品 ID 會產生警告
- 結構描述名稱會根據可用的結構描述進行驗證
- 內容有 50KB 的大小限制
- 無效的 YAML 會連同行號一起回報

### 疑難排解

**「rules 中不明的成品 ID：X」**
- 檢查成品 ID 是否與你的結構描述相符 (請參見上方清單)
- 執行 `openspec schemas --json` 來查看每個結構描述的成品 ID

**設定未套用：**
- 確保檔案位於 `openspec/config.yaml` (不是 `.yml`)
- 使用驗證器檢查 YAML 語法
- 設定變更會立即生效 (無需重啟)

**內容太大：**
- 內容限制為 50KB
- 請改用摘要或連結至外部文件

## 指令

| 指令             | 作用                                                  |
| ---------------- | ----------------------------------------------------- |
| `/opsx:explore`  | 思考想法、調查問題、釐清需求                          |
| `/opsx:new`      | 開始一個新變更                                        |
| `/opsx:continue` | 建立下一個成品 (基於已就緒的內容)                     |
| `/opsx:ff`       | 快進 (Fast-forward) — 一次建立所有規劃成品            |
| `/opsx:apply`    | 實作任務，並根據需要更新成品                          |
| `/opsx:sync`     | 將 delta 規格同步至主規格 (選用 — 如果需要可封存提示) |
| `/opsx:archive`  | 完成後封存                                            |

## 用法

### 探索想法
```
/opsx:explore
```
思考想法、調查問題、比較選項。無需固定結構 - 只是一個思考夥伴。當見解具體化時，轉換至 `/opsx:new` 或 `/opsx:ff`。

### 開始一個新變更
```
/opsx:new
```
系統會詢問你想建構什麼，以及要使用哪個工作流程結構描述。

### 建立成品
```
/opsx:continue
```
根據依賴關係顯示哪些成品已準備好建立，然後建立一個成品。重複使用以逐步建構你的變更。

```
/opsx:ff add-dark-mode
```
一次建立所有規劃成品。當你對要建構的內容有清晰的藍圖時使用。

### 實作 (流動部分)
```
/opsx:apply
```
執行任務，並在完成時勾選它們。如果你正在處理多個變更，可以執行 `/opsx:apply <名稱>`；否則它應該會從對話中推斷，如果無法判斷則會提示你選擇。

### 完成
```
/opsx:archive   # 完成後移至封存 (如果需要，會提示同步規格)
```

## 何時更新 vs. 重新開始

你隨時可以在實作前編輯你的提案或規格。但精煉何時會變成「這是不同的工作」？

### 提案捕捉了什麼

提案定義了三件事：
1. **意圖** — 你正在解決什麼問題？
2. **範疇** — 什麼在邊界內/外？
3. **方法** — 你將如何解決它？

問題是：哪一個改變了，改變了多少？

### 在以下情況更新現有變更：

**相同的意圖，精煉的執行**
- 你發現了之前未考慮的邊緣案例
- 方法需要調整，但目標未變
- 實作顯示設計略有偏差

**範疇縮小**
- 你意識到完整範疇太大，想先發佈 MVP
- 「新增深色模式」→「新增深色模式切換 (v2 中的系統偏好設定)」

**學習驅動的修正**
- 程式碼庫的結構不如你所想
- 依賴關係未如預期運作
- 「使用 CSS 變數」→「改用 Tailwind 的 dark: 前綴」

### 在以下情況開始新變更：

**意圖根本上改變了**
- 問題本身現在不同了
- 「新增深色模式」→「新增包含自訂顏色、字體、間距的全面主題系統」

**範疇爆炸**
- 變更增長太多，本質上已是不同的工作
- 原始提案在更新後將面目全非
- 「修正登入錯誤」→「重寫驗證系統」

**原始變更是可以完成的**
- 原始變更可以標記為「完成」
- 新工作是獨立的，而非精煉
- 完成「新增深色模式 MVP」→ 封存 → 新變更「強化深色模式」

### 啟發式方法

```
                        ┌─────────────────────────────────────┐
                        │     這是否為相同的工作？               │
                        └──────────────┬──────────────────────┘
                                       │
                    ┌──────────────────┼──────────────────┐
                    │                  │                  │
                    ▼                  ▼                  ▼
             意圖相同？         重疊 >50%？        原始變更是否可以在
             問題相同？         範疇相同？         沒有這些變更的情況下
                    │                  │           標記為「完成」？
                    │                  │                  │
          ┌────────┴────────┐  ┌──────┴──────┐   ┌───────┴───────┐
          │                 │  │             │   │               │
         是                否  是             否  否              是
          │                 │  │             │   │               │
          ▼                 ▼  ▼             ▼   ▼               ▼
        更新              新建 更新           新建  更新            新建
```

| 測試         | 更新                       | 新變更                           |
| ------------ | -------------------------- | -------------------------------- |
| **身分**     | 「相同的東西，已精煉」     | 「不同的工作」                   |
| **範疇重疊** | >50% 重疊                  | <50% 重疊                        |
| **完成度**   | 沒有變更就無法「完成」     | 可以完成原始變更，新工作獨立存在 |
| **故事**     | 更新鏈講述了一個連貫的故事 | 補丁會造成困惑而非釐清           |

### 原則

> **更新保留背景資訊。新變更提供清晰度。**
>
> 當你思考的歷史很有價值時，請選擇更新。
> 當重新開始比打補丁更清晰時，請選擇新建。

把它想成 git 分支：
- 在處理相同功能時持續提交
- 當它是真正的新工作時，開始一個新分支
- 有時合併部分功能，並為第二階段重新開始

## 有什麼不同？

|              | 舊版 (`/openspec:proposal`)  | OPSX (`/opsx:*`)                |
| ------------ | ---------------------------- | ------------------------------- |
| **結構**     | 一個大的提案文件             | 具有依賴關係的離散成品          |
| **工作流程** | 線性階段：規劃 → 實作 → 封存 | 流動行動 — 隨時執行任何操作     |
| **反覆運算** | 回頭變更很彆扭               | 在學習過程中更新成品            |
| **自訂**     | 固定結構                     | 結構描述驅動 (定義你自己的成品) |

**關鍵見解：** 工作不是線性的。OPSX 不再假裝它是。

## 架構深入探討

本節說明 OPSX 在底層是如何運作的，以及它與舊版工作流程的比較。

### 哲學：階段 vs. 行動

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         舊版工作流程                                          │
│                    (階段鎖定，全有或全無)                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌──────────────┐      ┌──────────────┐      ┌──────────────┐              │
│   │   規劃階段    │ ───► │   實作階段    │ ───► │   封存階段    │               │
│   └──────────────┘      └──────────────┘      └──────────────┘              │
│         │                     │                     │                       │
│         ▼                     ▼                     ▼                       │
│   /openspec:proposal   /openspec:apply      /openspec:archive               │
│                                                                             │
│   • 一次建立所有成品                                                           │
│   • 在實作期間無法回頭更新規格                                                  │
│   • 階段閘門強制執行線性進度                                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────────┐
│                            OPSX 工作流程                                     │
│                      (流動行動，反覆式)                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│              ┌─────────────────────────────────────────────┐                │
│              │           行動 (非階段)                      │                 │
│              │                                             │                │
│              │   new ◄──► continue ◄──► apply ◄──► archive │                │
│              │    │          │           │           │     │                │
│              │    └──────────┴───────────┴───────────┘     │                │
│              │              任何順序                        │                │
│              └─────────────────────────────────────────────┘                │
│                                                                             │
│   • 一次建立一個成品，或快進                                                   │
│   • 在實作期間更新規格/設計/任務                                                │
│   • 依賴關係促成進展，不存在階段                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 元件架構

**舊版工作流程**在 TypeScript 中使用硬編碼模板：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      舊版工作流程元件                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   硬編碼模板 (TypeScript 字串)                                                │
│                    │                                                        │
│                    ▼                                                        │
│   設定器 (Configurators) (18 個以上的類別，每個編輯器一個)                       │
│                    │                                                        │
│                    ▼                                                        │
│   產生的指令檔案 (.claude/commands/openspec/*.md)                             │
│                                                                             │
│   • 固定結構，無成品感知能力                                                    │
│   • 變更需要修改程式碼 + 重新建構                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**OPSX** 使用外部結構描述和依賴圖引擎：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         OPSX 元件                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   結構描述定義 (YAML)                                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  name: spec-driven                                                  │   │
│   │  artifacts:                                                         │   │
│   │    - id: proposal                                                   │   │
│   │      generates: proposal.md                                         │   │
│   │      requires: []              ◄── 依賴關係                          │   │
│   │    - id: specs                                                      │   │
│   │      generates: specs/**/*.md  ◄── Glob 模式                         │   │
│   │      requires: [proposal]      ◄── 在提案後啟用                       │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                    │                                                        │
│                    ▼                                                        │
│   成品圖形引擎 (Artifact Graph Engine)                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  • 拓撲排序 (依賴關係排序)                                             │   │
│   │  • 狀態偵測 (檔案系統是否存在)                                          │   │
│   │  • 豐富的指示產生 (模板 + 內容)                                        │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                    │                                                        │
│                    ▼                                                        │
│   技能檔案 (.claude/skills/openspec-*/SKILL.md)                              │
│                                                                             │
│   • 跨編輯器相容 (Claude Code, Cursor, Windsurf)                              │
│   • 技能向 CLI 查詢結構化資料                                                  │
│   • 透過結構描述檔案完全可自訂                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 依賴圖模型

成品形成一個有向無環圖 (DAG)。依賴關係是**促成因素**，而非閘門：

```
                              提案 (proposal)
                             (根節點)
                                  │
                    ┌─────────────┴─────────────┐
                    │                           │
                    ▼                           ▼
                規格 (specs)                 設計 (design)
              (需要：                      (需要：
               提案)                        提案)
                    │                           │
                    └─────────────┬─────────────┘
                                  │
                                  ▼
                              任務 (tasks)
                           (需要：
                           規格, 設計)
                                  │
                                  ▼
                          ┌──────────────┐
                          │ 實作 (APPLY) │
                          │ (需要：      │
                          │  任務)       │
                          └──────────────┘
```

**狀態轉換：**

```
   已封鎖 (BLOCKED) ───────────► 就緒 (READY) ───────────► 完成 (DONE)
      │                        │                       │
   缺少                     所有依賴項                檔案存在於
   依賴關係                  皆已「完成」              檔案系統上
```

### 資訊流

**舊版工作流程** — 代理程式接收靜態指示：

```
  使用者："/openspec:proposal"
           │
           ▼
  ┌──────────────────────────────────────────┐
  │  靜態指示：                               │
  │  • 建立 proposal.md                      │
  │  • 建立 tasks.md                         │
  │  • 建立 design.md                        │
  │  • 建立 specs/<capability>/spec.md       │
  │                                         │
  │  不感知已存在的內容或                      │
  │  成品之間的依賴關係                        │
  └──────────────────────────────────────────┘
           │
           ▼
  代理程式一次建立「所有」成品
```

**OPSX** — 代理程式查詢豐富的內容資訊：

```
  使用者："/opsx:continue"
           │
           ▼
  ┌──────────────────────────────────────────────────────────────────────────┐
  │  步驟 1：查詢目前狀態                                                       │
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │  $ openspec status --change "add-auth" --json                      │  │
  │  │                                                                    │  │
  │  │  {                                                                 │  │
  │  │    "artifacts": [                                                  │  │
  │  │      {"id": "proposal", "status": "done"},                         │  │
  │  │      {"id": "specs", "status": "ready"},      ◄── 第一個就緒的       │  │
  │  │      {"id": "design", "status": "ready"},                          │  │
  │  │      {"id": "tasks", "status": "blocked", "missingDeps": ["specs"]}│  │
  │  │    ]                                                               │  │
  │  │  }                                                                 │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  │  步驟 2：獲取就緒成品的豐富指示                                              |
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │  $ openspec instructions specs --change "add-auth" --json          │  │
  │  │                                                                    │  │
  │  │  {                                                                 │  │
  │  │    "template": "# 規格\n\n## 新增需求...",                           │  │
  │  │    "dependencies": [{"id": "proposal", "path": "...", "done": true}│  │
  │  │    "unlocks": ["tasks"]                                            │  │
  │  │  }                                                                 │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  │  步驟 3：讀取依賴關係 → 建立「一個」成品 → 顯示解鎖了什麼                       │
  └──────────────────────────────────────────────────────────────────────────┘
```

### 反覆運算模型

**舊版工作流程** — 反覆運算很困難：

```
  ┌─────────┐     ┌─────────┐     ┌─────────┐
  │/proposal│ ──► │ /apply  │ ──► │/archive │
  └─────────┘     └─────────┘     └─────────┘
       │               │
       │               ├── 「等等，設計錯了」
       │               │
       │               ├── 選項：
       │               │   • 手動編輯檔案 (破壞內容連結)
       │               │   • 放棄並重新開始
       │               │   • 硬著頭皮做，稍後再修正
       │               │
       │               └── 沒有正式的「回頭」機制
       │
       └── 一次建立所有成品
```

**OPSX** — 自然的反覆運算：

```
  /opsx:new ───► /opsx:continue ───► /opsx:apply ───► /opsx:archive
      │                │                  │
      │                │                  ├── 「設計錯了」
      │                │                  │
      │                │                  ▼
      │                │            直接編輯 design.md
      │                │            然後繼續！
      │                │                  │
      │                │                  ▼
      │                │         /opsx:apply 會從
      │                │         你離開的地方繼續
      │                │
      │                └── 建立一個成品，顯示解鎖了什麼
      │
      └── 搭建變更鷹架，等待指示
```

### 自訂結構描述 (Custom Schemas)

使用結構描述管理指令建立自訂工作流程：

```bash
# 從頭開始建立新結構描述 (互動式)
openspec schema init my-workflow

# 或複製現有結構描述作為起點
openspec schema fork spec-driven my-workflow

# 驗證你的結構描述結構
openspec schema validate my-workflow

# 查看結構描述從何處解析 (對除錯很有用)
openspec schema which my-workflow
```

結構描述儲存在 `openspec/schemas/` (專案本地，受版本控制) 或 `~/.local/share/openspec/schemas/` (使用者全域)。

**結構描述結構：**
```
openspec/schemas/research-first/
├── schema.yaml
└── templates/
    ├── research.md
    ├── proposal.md
    └── tasks.md
```

**schema.yaml 範例：**
```yaml
name: research-first
artifacts:
  - id: research        # 在提案前新增
    generates: research.md
    requires: []

  - id: proposal
    generates: proposal.md
    requires: [research]  # 現在依賴於研究 (research)

  - id: tasks
    generates: tasks.md
    requires: [proposal]
```

**依賴圖：**
```
   research ──► proposal ──► tasks
```

### 摘要

| 面向           | 舊版                  | OPSX                 |
| -------------- | --------------------- | -------------------- |
| **模板**       | 硬編碼的 TypeScript   | 外部 YAML + Markdown |
| **依賴關係**   | 無 (一次全部)         | 具有拓撲排序的 DAG   |
| **狀態**       | 基於階段的心理模型    | 檔案系統是否存在     |
| **自訂**       | 編輯原始碼，重新建構  | 建立 schema.yaml     |
| **反覆運算**   | 階段鎖定              | 流動，編輯任何內容   |
| **編輯器支援** | 18 個以上的設定器類別 | 單一技能目錄         |


## 結構描述 (Schemas)

結構描述定義了存在哪些成品及其依賴關係。目前可用：

- **spec-driven** (預設)：提案 → 規格 → 設計 → 任務

```bash
# 列出可用的結構描述
openspec schemas

# 查看所有結構描述及其解析來源
openspec schema which --all

# 互動式建立新結構描述
openspec schema init my-workflow

# 複製現有結構描述進行自訂
openspec schema fork spec-driven my-workflow

# 使用前驗證結構描述結構
openspec schema validate my-workflow
```

## 提示

- 在致力於變更之前，使用 `/opsx:explore` 思考想法
- 當你知道自己想要什麼時使用 `/opsx:ff`，在探索時使用 `/opsx:continue`
- 在 `/opsx:apply` 期間，如果發現錯誤 — 修正成品，然後繼續
- 任務透過 `tasks.md` 中的核取方塊追蹤進度
- 隨時檢查狀態：`openspec status --change "名稱"`

## 回饋

這還很簡略。這是故意的 — 我們正在學習什麼最有效。

發現錯誤？有想法嗎？請加入我們的 [Discord](https://discord.gg/YctCnvvshC) 或在 [GitHub](https://github.com/Fission-AI/openspec/issues) 開啟 issue。
