# OPSX 工作流程

> **相容性：** 目前僅支援 Claude Code。歡迎在 [Discord](https://discord.gg/YctCnvvshC) 提供回饋。

## 它是什麼？

OPSX 是一種用於 OpenSpec 變更的 **流動、疊代工作流程**。不再有僵化的階段 — 只有您可以隨時執行的動作。

## 為什麼存在這個功能？

標準的 OpenSpec 工作流程雖然有效，但它是 **鎖定** 的：

- **指示是寫死的 (hardcoded)** — 埋在 TypeScript 中，您無法變更它們
- **全有或全無 (All-or-nothing)** — 一個大指令建立所有內容，無法測試單個部分
- **固定結構** — 每個人都使用相同的工作流程，無法自訂
- **黑盒子** — 當 AI 輸出不佳時，您無法微調提示 (prompts)

**OPSX 開放了這一切。** 現在任何人都可以：

1. **實驗指示** — 編輯範本，看看 AI 是否表現得更好
2. **細粒度測試** — 獨立驗證每個成品的指示
3. **自訂工作流程** — 定義您自己的成品和相依性
4. **快速疊代** — 變更範本，立即測試，無需重新建置

```
標準工作流程：                         OPSX：
┌────────────────────────┐           ┌────────────────────────┐
│  套件中寫死的內容        │           │  schema.yaml           │◄── 您編輯此項
│  (無法變更)             │           │  templates/*.md        │◄── 或此項
│        ↓               │           │        ↓               │
│  等待新版本釋出          │           │  立即生效               │
│        ↓               │           │        ↓               │
│  希望它會變得更好        │           │  自行測試               │
└────────────────────────┘           └────────────────────────┘
```

**這是為每個人設計的：**
- **團隊** — 建立符合您實際工作方式的工作流程
- **進階使用者** — 微調提示以獲得更適合您的程式碼庫的 AI 輸出
- **OpenSpec 貢獻者** — 在不釋出版本的情況下嘗試新方法

我們都在學習什麼最有效。OPSX 讓我們一起學習。

## 使用者體驗

**線性工作流程的問題：**
您處於「規劃階段」，然後是「實作階段」，最後「完成」。但實際工作並非如此運作。您實作了一些內容，意識到您的設計錯了，需要更新規格，然後繼續實作。線性階段與工作的實際運作方式背道而馳。

**OPSX 方法：**
- **動作，而非階段** — 建立、實作、更新、封存 — 隨時執行其中任何一項
- **相依性是推動因素** — 它們顯示可以做什麼，而不是接下來必須做什麼

```
  提案 ──→ 規格 ──→ 設計 ──→ 任務 ──→ 實作
```

## 設定

```bash
# 1. 確保您已安裝並初始化 OpenSpec
openspec init

# 2. 產生實驗性技能 (experimental skills)
openspec experimental
```

這將在 `.claude/skills/` 中建立 Claude Code 會自動偵測的技能。

在設定期間，系統會提示您建立 **專案設定 (project config)** (`openspec/config.yaml`)。這是選用的，但建議建立。

## 專案設定

專案設定讓您能夠設定預設值，並將專案特定的背景資訊注入到所有成品中。

### 建立設定

設定是在 `experimental` 過程中建立的，也可以手動建立：

```yaml
# openspec/config.yaml
schema: spec-driven

context: |
  技術堆疊：TypeScript, React, Node.js
  API 慣例：RESTful, JSON 回應
  測試：單元測試使用 Vitest，e2e 使用 Playwright
  風格：ESLint 搭配 Prettier, 嚴格的 TypeScript

rules:
  proposal:
    - 包含回滾計畫
    - 識別受影響的團隊
  specs:
    - 情境使用 Given/When/Then 格式
  design:
    - 為複雜流程包含循序圖
```

### 設定欄位

| 欄位      | 類型 | 說明                                             |
| --------- | ---- | ------------------------------------------------ |
| `schema`  | 字串 | 新變更的預設 schema (例如：`spec-driven`, `tdd`) |
| `context` | 字串 | 注入到所有成品指示中的專案背景資訊               |
| `rules`   | 物件 | 針對每個成品的規則，以成品 ID 為鍵 (key)         |

### 它如何運作

**Schema 優先順序** (由高至低)：
1. CLI 旗標 (`--schema tdd`)
2. 變更 Metadata (變更目錄中的 `.openspec.yaml`)
3. 專案設定 (`openspec/config.yaml`)
4. 預設值 (`spec-driven`)

**背景資訊注入：**
- 背景資訊會附加到每個成品的指示前面
- 包裹在 `<context>...</context>` 標籤中
- 協助 AI 瞭解您專案的慣例

**規則注入：**
- 規則僅注入到相符的成品中
- 包裹在 `<rules>...</rules>` 標籤中
- 出現在背景資訊之後、範本之前

### 按 Schema 分類的成品 ID

**spec-driven** (預設)：
- `proposal` — 變更提案
- `specs` — 規格
- `design` — 技術設計
- `tasks` — 實作任務

**tdd**：
- `spec` — 功能規格
- `tests` — 測試檔案
- `implementation` — 實作程式碼
- `docs` — 文件

### 設定驗證

- `rules` 中不明的成品 ID 會產生警告
- Schema 名稱會根據可用的 schema 進行驗證
- 背景資訊 (context) 有 50KB 的大小限制
- 無效的 YAML 將報告行號

### 疑難排解

**「規則中不明的成品 ID：X (Unknown artifact ID in rules: X)」**
- 檢查成品 ID 是否符合您的 schema (請參閱上方清單)
- 執行 `openspec schemas --json` 以查看每個 schema 的成品 ID

**設定未生效：**
- 確保檔案位於 `openspec/config.yaml`（而非 `.yml`）
- 使用驗證器檢查 YAML 語法
- 設定變更會立即生效（無需重新啟動）

**背景資訊過大：**
- 背景資訊限制為 50KB
- 請總結或連結到外部文件

## 指令

| 指令             | 它的作用                                            |
| ---------------- | --------------------------------------------------- |
| `/opsx:explore`  | 思考想法、調查問題、釐清需求                        |
| `/opsx:new`      | 開始一個新的變更                                    |
| `/opsx:continue` | 建立下一個成品（根據已就緒的內容）                  |
| `/opsx:ff`       | 快進 — 一次建立所有規劃成品                         |
| `/opsx:apply`    | 實作任務，根據需要更新成品                          |
| `/opsx:sync`     | 將差異規格同步到主規格（選用 — 封存會在需要時提示） |
| `/opsx:archive`  | 完成後封存                                          |

## 用法

### 探索想法
```
/opsx:explore
```
思考想法、調查問題、比較選項。不需要特定結構 — 就像一個思考夥伴。當想法具體化時，轉換到 `/opsx:new` 或 `/opsx:ff`。

### 開始一個新的變更
```
/opsx:new
```
系統會詢問您想要建構什麼以及要使用哪個工作流程 schema。

### 建立成品
```
/opsx:continue
```
根據相依性顯示準備好建立的成品，然後建立一個成品。重複使用以增量方式構建您的變更。

```
/opsx:ff add-dark-mode
```
一次建立所有規劃成品。當您對要建構的內容有清晰的瞭解時使用。

### 實作（流動的部分）
```
/opsx:apply
```
處理任務，在完成時將其勾選。如果您正在同時處理多個變更，可以執行 `/opsx:apply <name>`；否則它應該從對話中推斷，如果無法判斷則會提示您選擇。

### 完成
```
/opsx:archive   # 完成時移至封存（如果需要則提示同步規格）
```

## 何時更新 vs. 重新開始

您始終可以在實作之前編輯提案或規格。但精煉何時會變成「這是不同的工作」？

### 提案捕捉的內容

提案定義了三件事：
1. **意圖** — 您正在解決什麼問題？
2. **範圍** — 哪些在範圍內/外？
3. **方法** — 您將如何解決它？

問題是：哪一項改變了，以及改變了多少？

### 在以下情況更新現有變更：

**相同的意圖，精煉的執行**
- 您發現了以前沒考慮到的邊緣情況
- 方法需要微調，但目標未變
- 實作顯示設計略有偏差

**範圍縮小**
- 您意識到完整的範圍太大，想要先發布 MVP
- 「新增深色模式」 → 「新增深色模式切換按鈕 (系統偏好在 v2 中提供)」

**學習驅動的修正**
- 程式碼結構與您想像的不同
- 相依項無法如預期運作
- 「使用 CSS 變數」 → 「改用 Tailwind 的 dark: 前綴」

### 在以下情況建立新變更：

**意圖發生根本變化**
- 問題本身現在不同了
- 「新增深色模式」 → 「新增包含自訂顏色、字體、間距的全面主題系統」

**範圍爆炸**
- 變更增長太多，以至於本質上是不同的工作
- 原始提案在更新後將變得面目全非
- 「修復登入錯誤」 → 「重寫驗證系統」

**原始變更是可以完成的**
- 原始變更可以標記為「已完成」
- 新工作獨立存在，而非精煉
- 完成「新增深色模式 MVP」 → 封存 → 新變更「增強深色模式」

### 啟發式方法

```
                        ┌─────────────────────────────────────┐
                        │     這是同樣的工作嗎？                 │
                        └──────────────┬──────────────────────┘
                                       │
                    ┌──────────────────┼──────────────────┐
                    │                  │                  │
                    ▼                  ▼                  ▼
             意圖相同？        >50% 重疊？        原始變更在
             問題相同？        範圍相同？         沒有這些變更
                    │                  │          下可以「完成」嗎？
                    │                  │                  │
          ┌────────┴────────┐  ┌──────┴──────┐   ┌───────┴───────┐
          │                 │  │             │   │               │
         是                否  是            否  否              是
          │                 │  │             │   │               │
          ▼                 ▼  ▼             ▼   ▼               ▼
        更新              新建 更新            新建 更新            新建
```

| 測試         | 更新                       | 新變更                             |
| ------------ | -------------------------- | ---------------------------------- |
| **身份**     | 「同一件事，精煉」         | 「不同的工作」                     |
| **範圍重疊** | >50% 重疊                  | <50% 重疊                          |
| **完成度**   | 沒有變更就無法「完成」     | 可以完成原始變更，新工作獨立存在   |
| **故事性**   | 更新鏈講述了一個連貫的故事 | 修補程式只會讓事情更混亂，而非清晰 |

### 原則

> **更新保留背景資訊。新變更提供清晰度。**
>
> 當您思考的歷史具有價值時，選擇更新。 
> 當重新開始比修補更清晰時，選擇新建。

可以把它想像成 git 分支：
- 在處理相同功能時持續提交
- 當它確實是新工作時開始一個新分支
- 有時合併一個部分功能，然後為第 2 階段重新開始

## 有什麼不同？

|              | 標準 (`/openspec:proposal`)  | 實驗性 (`/opsx:*`)              |
| ------------ | ---------------------------- | ------------------------------- |
| **結構**     | 一份大的提案文件             | 具有相依性的獨立成品            |
| **工作流程** | 線性階段：規劃 → 實作 → 封存 | 流動動作 — 隨時執行任何操作     |
| **疊代**     | 回頭處理很尷尬               | 隨著學習更新成品                |
| **自訂**     | 固定結構                     | Schema 驅動（定義您自己的成品） |

**關鍵洞察：** 工作不是線性的。OPSX 不再假裝它是線性的。

## 架構深度探討

本節說明 OPSX 在底層如何運作，以及它與標準工作流程的比較。

### 理念：階段 vs 動作

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         標準工作流程                                         │
│                    (階段鎖定，全有或全無)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌──────────────┐      ┌──────────────┐      ┌──────────────┐              │
│   │   規劃階段    │ ───► │   實作階段    │ ───► │   封存階段    │              │
│   └──────────────┘      └──────────────┘      └──────────────┘              │
│         │                     │                     │                       │
│         ▼                     ▼                     ▼                       │
│   /openspec:proposal   /openspec:apply      /openspec:archive               │
│                                                                             │
│   • 一次建立所有成品                                                          │
│   • 無法在實作期間回頭更新規格                                                  │
│   • 階段門檻強制執行線性進展                                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────────┐
│                            OPSX 工作流程                                     │
│                      (流動動作，疊代)                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│              ┌────────────────────────────────────────────┐                 │
│              │           動作 (而非階段)                    │                 │
│              │                                            │                 │
│              │   new ◄──► continue ◄──► apply ◄──► archive │                │
│              │    │          │           │           │    │                 │
│              │    └──────────┴───────────┴───────────┘    │                 │
│              │              任何順序                       │                 │
│              └────────────────────────────────────────────┘                 │
│                                                                             │
│   • 一次建立一個成品或快進                                                     │
│   • 在實作期間更新規格/設計/任務                                                │
│   • 相依性推動進展，階段不存在                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 元件架構

**標準工作流程** 在 TypeScript 中使用寫死的範本：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      標準工作流程元件                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   寫死的範本 (TypeScript 字串)                                                │
│                    │                                                        │
│                    ▼                                                        │
│   設定器 (Configurators) (18 個以上的類別，每個編輯器一個)                       │
│                    │                                                        │
│                    ▼                                                        │
│   產生的指令檔案 (.claude/commands/openspec/*.md)                             │
│                                                                             │
│   • 固定結構，不具備成品意識                                                    │
│   • 變更需要修改程式碼 + 重新建置                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**OPSX** 使用外部 schema 和相依圖引擎：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         OPSX 元件                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Schema 定義 (YAML)                                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  name: spec-driven                                                  │   │
│   │  artifacts:                                                         │   │
│   │    - id: proposal                                                   │   │
│   │      generates: proposal.md                                         │   │
│   │      requires: []              ◄── 相依性                            │   │
│   │    - id: specs                                                      │   │
│   │      generates: specs/**/*.md  ◄── Glob 模式                         │   │
│   │      requires: [proposal]      ◄── 在提案後啟用                       │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                    │                                                        │
│                    ▼                                                        │
│   成品圖引擎 (Artifact Graph Engine)                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  • 拓撲排序 (相依順序)                                                │   │
│   │  • 狀態偵測 (檔案系統是否存在)                                          │   │
│   │  • 豐富的指示產生 (範本 + 背景資訊)                                     │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                    │                                                        │
│                    ▼                                                        │
│   技能檔案 (.claude/skills/openspec-*/SKILL.md)                              │
│                                                                             │
│   • 跨編輯器相容 (Claude Code, Cursor, Windsurf)                              │
│   • 技能向 CLI 查詢結構化資料                                                  │
│   • 可透過 schema 檔案完全自訂                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 相依圖模型

成品形成一個有向無環圖 (DAG)。相依性是 **推動因素**，而非門檻：

```
                              proposal
                               (根節點)
                                  │
                    ┌─────────────┴─────────────┐
                    │                           │
                    ▼                           ▼
                 specs                       design
              (需要：                      (需要：
               proposal)                   proposal)
                    │                           │
                    └─────────────┬─────────────┘
                                  │
                                  ▼
                               tasks
                            (需要：
                            specs, design)
                                  │
                                  ▼
                          ┌──────────────┐
                          │  實作階段    │
                          │  (需要：      │
                          │   tasks)     │
                          └──────────────┘
```

**狀態轉換：**

```
   已封鎖 (BLOCKED) ──────────► 就緒 (READY) ──────────► 完成 (DONE) 
          │                        │                       │
       缺少相依項               所有相依項              檔案存在於
                                為「完成」              檔案系統中
```

### 資訊流

**標準工作流程** — 代理接收靜態指示：

```
  使用者："/openspec:proposal"
           │
           ▼
  ┌─────────────────────────────────────────┐
  │  靜態指示：                              │
  │  • 建立 proposal.md                     │
  │  • 建立 tasks.md                        │
  │  • 建立 design.md                       │
  │  • 建立 specs/*.md                      │
  │                                         │
  │  不知道已存在的內容或                      │
  │  成品之間的相依性                         │
  └─────────────────────────────────────────┘
           │
           ▼
  代理一次建立所有成品
```

**OPSX** — 代理查詢豐富的內容背景：

```
  使用者："/opsx:continue"
           │
           ▼
  ┌──────────────────────────────────────────────────────────────────────────┐
  │  步驟 1：查詢目前狀態                                                       │
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │  $ openspec status --change "add-auth" --json                      │  │
  │  │                                                                    │  │
  │  │  {                                                                 │  │
  │  │    "artifacts": [                                                  │  │
  │  │      {"id": "proposal", "status": "done"},                         │  │
  │  │      {"id": "specs", "status": "ready"},      ◄── 第一個就緒的       │  │
  │  │      {"id": "design", "status": "ready"},                          │  │
  │  │      {"id": "tasks", "status": "blocked", "missingDeps": ["specs"]}│  │
  │  │    ]                                                               │  │
  │  │  }                                                                 │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  │  步驟 2：獲取就緒成品的豐富指示                                              │
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │  $ openspec instructions specs --change "add-auth" --json          │  │
  │  │                                                                    │  │
  │  │  {                                                                 │  │
  │  │    "template": "# Specification\n\n## ADDED Requirements...",      │  │
  │  │    "dependencies": [{"id": "proposal", "path": "...", "done": true}│  │
  │  │    "unlocks": ["tasks"]                                            │  │
  │  │  }                                                                 │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  │  步驟 3：讀取相依項 → 建立一個成品 → 顯示已解鎖的內容                          │
  └──────────────────────────────────────────────────────────────────────────┘
```

### 疊代模型

**標準工作流程** — 疊代很尷尬：

```
  ┌─────────┐     ┌─────────┐     ┌─────────┐
  │/proposal│ ──► │ /apply  │ ──► │/archive │
  └─────────┘     └─────────┘     └─────────┘
       │               │
       │               ├── 「等等，設計錯了」
       │               │
       │               ├── 選項：
       │               │   • 手動編輯檔案（破壞背景內容）
       │               │   • 放棄並重新開始
       │               │   • 勉強繼續，稍後修復
       │               │
       │               └── 沒有正式的「回退」機制
       │
       └── 一次建立所有成品
```

**OPSX** — 自然的疊代：

```
  /opsx:new ───► /opsx:continue ───► /opsx:apply ───► /opsx:archive
      │                │                  │
      │                │                  ├── 「設計錯了」
      │                │                  │
      │                │                  ▼
      │                │            直接編輯 design.md
      │                │            然後繼續！
      │                │                  │
      │                │                  ▼
      │                │         /opsx:apply 從您
      │                │         停下的地方接續
      │                │
      │                └── 一次建立一個成品，顯示已解鎖內容
      │
      └── 建構變更，等待指令
```

### 自訂 Schema

使用 schema 管理指令建立自訂工作流程：

```bash
# 從頭開始建立新 schema (互動式)
openspec schema init my-workflow

# 或分支現有 schema 作為起點
openspec schema fork spec-driven my-workflow

# 驗證您的 schema 結構
openspec schema validate my-workflow

# 查看 schema 解析自何處 (對偵錯很有用)
openspec schema which my-workflow
```

Schema 儲存在 `openspec/schemas/` (專案本地，受版本控制) 或 `~/.local/share/openspec/schemas/` (使用者全域)。

**Schema 結構：**
```
openspec/schemas/research-first/
├── schema.yaml
└── templates/
    ├── research.md
    ├── proposal.md
    └── tasks.md
```

**範例 schema.yaml：**
```yaml
name: research-first
artifacts:
  - id: research        # 在提案之前新增
    generates: research.md
    requires: []

  - id: proposal
    generates: proposal.md
    requires: [research]  # 現在相依於研究
  - id: tasks
    generates: tasks.md
    requires: [proposal]
```

**相依圖：**
```
   研究 ──► 提案 ──► 任務
```

### 摘要

| 面向           | 標準                  | OPSX                 |
| -------------- | --------------------- | -------------------- |
| **範本**       | 寫死的 TypeScript     | 外部 YAML + Markdown |
| **相依性**     | 無（一次完成）        | 具有拓撲排序的 DAG   |
| **狀態**       | 基於階段的心理模型    | 檔案系統是否存在     |
| **自訂**       | 編輯原始碼，重新建置  | 建立 schema.yaml     |
| **疊代**       | 階段鎖定              | 流動，編輯任何內容   |
| **編輯器支援** | 18 個以上的設定器類別 | 單一技能目錄         |

## Schema

Schema 定義了存在哪些成品及其相依性。目前可用：

- **spec-driven** (預設)：proposal → specs → design → tasks
- **tdd**：tests → implementation → docs

```bash
# 列出可用的 schema
openspec schemas

# 查看所有 schema 及其解析來源
openspec schema which --all

# 以互動方式建立新 schema
openspec schema init my-workflow

# 分支現有 schema 進行自訂
openspec schema fork spec-driven my-workflow

# 使用前驗證 schema 結構
openspec schema validate my-workflow
```

## 提示

- 在投入變更之前，使用 `/opsx:explore` 思考想法
- 當您知道想要什麼時使用 `/opsx:ff`，在探索時使用 `/opsx:continue`
- 在 `/opsx:apply` 期間，如果發現錯誤 — 修復成品，然後繼續
- 任務透過 `tasks.md` 中的複選框追蹤進度
- 隨時檢查狀態：`openspec status --change "name"`

## 回饋

這還比較粗糙。這是刻意的 — 我們正在學習什麼最有效。

發現錯誤？有構想嗎？請在 [Discord](https://discord.gg/YctCnvvshC) 加入我們，或在 [GitHub](https://github.com/Fission-AI/openspec/issues) 提交 issue。
