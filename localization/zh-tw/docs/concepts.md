# 核心概念

本指南說明了 OpenSpec 背後的核心構想以及它們如何整合在一起。有關實際用法，請參閱 [入門指南](getting-started.md) 和 [工作流程](workflows.md)。

## 理念

OpenSpec 圍繞著四個原則構建：

```
流動而非僵化       — 無階段門檻，處理合理的工作
疊代而非瀑布       — 邊做邊學，邊做邊完善
簡單而非複雜       — 輕量化設定，最小化流程
既有專案優先       — 適用於現有程式碼庫，而不僅僅是新專案
```

### 為什麼這些原則很重要

**流動而非僵化。** 傳統的規格系統將您鎖定在各個階段：首先規劃，然後實作，最後完成。OpenSpec 更加靈活 — 您可以按任何對您的工作有意義的順序建立成品。

**疊代而非瀑布。** 需求會變。理解會加深。一開始看起來不錯的方法，在您看到程式碼庫後可能站不住腳。OpenSpec 擁抱這一現實。

**簡單而非複雜。** 某些規格框架需要大量的設定、僵化的格式或沉重的流程。OpenSpec 不會妨礙您的工作。幾秒鐘內即可完成初始化，立即開始工作，僅在需要時進行自訂。

**既有專案優先。** 大多數軟體工作都不是從頭開始構建 — 而是修改現有系統。OpenSpec 基於差異 (delta) 的方法使其可以輕鬆地指定對現有行為的變更，而不僅僅是描述新系統。

## 大局觀

OpenSpec 將您的工作組織成兩個主要區域：

```
┌─────────────────────────────────────────────────────────────────┐
│                        openspec/                                │
│                                                                 │
│   ┌─────────────────────┐      ┌──────────────────────────────┐ │
│   │       specs/        │      │         changes/             │ │
│   │                     │      │                              │ │
│   │  單一事實來源         │◄─────│  提議的修改                   │ │
│   │  您的系統目前         │ 合併 │  每個變更 = 一個資料夾          │ │
│   │  如何運作            │      │  包含成品 + 差異               │ │
│   │                     │      │                              │ │
│   └─────────────────────┘      └──────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**規格 (Specs)** 是單一事實來源 — 它們描述了您的系統目前的行為方式。

**變更 (Changes)** 是提議的修改 — 它們存放在獨立的資料夾中，直到您準備好合併它們。

這種分離是關鍵。您可以平行處理多個變更而不會發生衝突。您可以在變更影響主規格之前對其進行檢視。當您封存變更時，它的差異會乾淨地合併到單一事實來源中。

## 規格 (Specs)

規格使用結構化需求和情境來描述系統的行為。

### 結構

```
openspec/specs/
├── auth/
│   └── spec.md           # 身份驗證行為
├── payments/
│   └── spec.md           # 付款處理
├── notifications/
│   └── spec.md           # 通知系統
└── ui/
    └── spec.md           # UI 行為和主題
```

按領域 (domain) 組織規格 — 對您的系統有意義的邏輯分組。常見模式：

- **按功能區域**：`auth/`、`payments/`、`search/`
- **按元件**：`api/`、`frontend/`、`workers/`
- **按限定內容 (bounded context)**：`ordering/`、`fulfillment/`、`inventory/`

### 規格格式

一個規格包含需求，每個需求都有情境：

```markdown
# 驗證規格

## 目的
應用程式的身份驗證和工作階段管理。

## 需求

### 需求：使用者身份驗證
系統應 (SHALL) 在成功登入後核發 JWT token。

#### 情境：有效憑證
- 假設 (GIVEN) 使用者具有有效憑證
- 當 (WHEN) 使用者提交登入表單時
- 那麼 (THEN) 回傳 JWT token
- 並且 (AND) 使用者被重新導向到儀表板

#### 情境：無效憑證
- 假設 (GIVEN) 無效憑證
- 當 (WHEN) 使用者提交登入表單時
- 那麼 (THEN) 顯示錯誤訊息
- 並且 (AND) 不核發 token

### 需求：工作階段過期
系統必須 (MUST) 在閒置 30 分鐘後讓工作階段過期。

#### 情境：閒置逾時
- 假設 (GIVEN) 一個已驗證的工作階段
- 當 (WHEN) 30 分鐘沒有活動時
- 那麼 (THEN) 工作階段失效
- 並且 (AND) 使用者必須重新驗證
```

**關鍵元素：**

| 元素              | 用途                           |
| ----------------- | ------------------------------ |
| `## 目的`         | 此規格領域的高階說明           |
| `### 需求：`      | 系統必須具備的特定行為         |
| `#### 情境：`     | 需求執行中的具體範例           |
| SHALL/MUST/SHOULD | 指示需求強度的 RFC 2119 關鍵字 |

### 為什麼要這樣組織規格

**需求是「做什麼 (what)」** — 它們陳述系統應該做什麼，而不指定實作方式。

**情境是「何時 (when)」** — 它們提供可以驗證的具體範例。良好的情境：
- 是可測試的（您可以為其編寫自動化測試）
- 涵蓋快樂路徑 (happy path) 和邊緣情況
- 使用 Given/When/Then 或類似的結構化格式

**RFC 2119 關鍵字** (SHALL、MUST、SHOULD、MAY) 傳達意圖：
- **MUST/SHALL** — 絕對需求
- **SHOULD** — 建議，但存在例外情況
- **MAY** — 選用

## 變更 (Changes)

變更是一個提議對系統進行的修改，被包裝成一個資料夾，其中包含理解和實作它所需的一切。

### 變更結構

```
openspec/changes/add-dark-mode/
├── proposal.md           # 為什麼和做什麼
├── design.md             # 如何做 (技術方法)
├── tasks.md              # 實作檢查清單
├── .openspec.yaml        # 變更 Metadata (選用)
└── specs/                # 差異規格
    └── ui/
        └── spec.md       # ui/spec.md 中正在變更的內容
```

每個變更都是自給自足的。它具有：
- **成品 (Artifacts)** — 捕捉意圖、設計和任務的文件
- **差異規格 (Delta specs)** — 關於正在新增、修改或移除內容的規格
- **Metadata** — 此特定變更的選用設定

### 為什麼變更是資料夾

將變更包裝為資料夾有幾個好處：

1. **所有內容都在一起。** 提案、設計、任務和規格都放在同一個地方。不需要在不同位置搜尋。

2. **平行工作。** 可以同時存在多個變更而不會衝突。在 `add-dark-mode` 進行的同時處理 `fix-auth-bug`。

3. **乾淨的歷史記錄。** 封存時，變更會移動到 `changes/archive/`，並保留其完整的內容背景。您可以回頭查看並瞭解不僅僅是更改了什麼，還有為什麼更改。

4. **對檢閱友善。** 變更資料夾易於檢閱 — 開啟它，閱讀提案，檢查設計，查看規格差異。

## 成品 (Artifacts)

成品是變更資料夾中引導工作的文件。

### 成品流程

```
   提案 ──────► 規格 ──────► 設計 ──────► 任務 ──────► 實作
    │            │           │            │
   為什麼       做什麼       如何做        步驟
 + 範圍         變更         方法         採取
```

成品相互建構。每個成品都為下一個成品提供內容背景。

### 成品類型

#### 提案 (`proposal.md`)

提案在高階層面捕捉 **意圖**、**範圍** 和 **方法**。

```markdown
# 提案：新增深色模式

## 意圖
使用者要求提供深色模式選項，以減少夜間使用時的眼睛疲勞，並符合系統偏好。

## 範圍
包含在內：
- 設定中的主題切換
- 系統偏好偵測
- 將偏好儲存在 localStorage 中

不包含：
- 自訂色彩主題（未來工作）
- 逐頁主題覆寫

## 方法
使用 CSS 自訂屬性進行佈景主題設定，並使用 React context 進行狀態管理。
首次載入時偵測系統偏好，允許手動覆寫。
```

**何時更新提案：**
- 範圍變更（縮小或擴大）
- 意圖釐清（對問題有更好的理解）
- 方法發生根本性轉變

#### 規格 (位於 `specs/` 中的差異規格)

差異規格描述相對於目前規格的 **變更內容**。請參閱下方的 [差異規格](#差異規格)。

#### 設計 (`design.md`)

設計捕捉 **技術方法** 和 **架構決策**。

```markdown
# 設計：新增深色模式

## 技術方法
透過 React Context 管理主題狀態，以避免屬性鑽取 (prop drilling)。
CSS 自訂屬性支援執行階段切換，無需切換類別。

## 架構決策

### 決策：Context 優於 Redux
使用 React Context 處理主題狀態，因為：
- 簡單的二進位狀態（亮/暗）
- 沒有複雜的狀態轉換
- 避免增加 Redux 相依性

### 決策：CSS 自訂屬性
使用 CSS 變數而不是 CSS-in-JS，因為：
- 適用於現有樣式表
- 無執行階段開銷
- 瀏覽器原生解決方案

## 資料流
```
ThemeProvider (context)
       │
       ▼
ThemeToggle ◄──► localStorage
       │
       ▼
CSS Variables (套用於 :root)
```

## 檔案變更
- `src/contexts/ThemeContext.tsx` (建立)
- `src/components/ThemeToggle.tsx` (建立)
- `src/styles/globals.css` (修改)
```

**何時更新設計：**
- 實作顯示該方法無效
- 發現更好的解決方案
- 相依性或約束發生變化

#### 任務 (`tasks.md`)

任務是 **實作檢查清單** — 帶有複選框的具體步驟。

```markdown
# 任務

## 1. 主題基礎設施
- [ ] 1.1 建立具有亮/暗狀態的 ThemeContext
- [ ] 1.2 為顏色新增 CSS 自訂屬性
- [ ] 1.3 實作 localStorage 持久化
- [ ] 1.4 新增系統偏好偵測

## 2. UI 元件
- [ ] 2.1 建立 ThemeToggle 元件
- [ ] 2.2 在設定頁面新增切換按鈕
- [ ] 2.3 更新 Header 以包含快速切換

## 3. 樣式設定
- [ ] 3.1 定義深色主題調色盤
- [ ] 3.2 更新元件以使用 CSS 變數
- [ ] 3.3 測試無障礙設計的對比度
```

**任務最佳實踐：**
- 將相關任務分組在標題下
- 使用階層式編號 (1.1, 1.2 等)
- 保持任務足夠小，以便在一個階段內完成
- 完成任務後將其勾選

## 差異規格 (Delta Specs)

差異規格是使 OpenSpec 適用於現有專案開發的關鍵概念。它們描述 **正在變更的內容**，而不是重述整個規格。

### 格式

```markdown
# Auth 差異

## 新增 (ADDED) 需求

### 需求：雙重身份驗證
系統必須 (MUST) 支援基於 TOTP 的雙重身份驗證。

#### 情境：2FA 註冊
- 假設 (GIVEN) 使用者未啟用 2FA
- 當 (WHEN) 使用者在設定中啟用 2FA 時
- 那麼 (THEN) 顯示用於驗證器應用程式設定的 QR code
- 並且 (AND) 使用者在啟動前必須使用代碼進行驗證

#### 情境：2FA 登入
- 假設 (GIVEN) 使用者已啟用 2FA
- 當 (WHEN) 使用者提交有效憑證時
- 那麼 (THEN) 呈現 OTP 挑戰
- 並且 (AND) 僅在輸入有效 OTP 後才完成登入

## 修改 (MODIFIED) 需求

### 需求：工作階段過期
系統必須 (MUST) 在閒置 15 分鐘後讓工作階段過期。
(先前為：30 分鐘)

#### 情境：閒置逾時
- 假設 (GIVEN) 一個已驗證的工作階段
- 當 (WHEN) 15 分鐘沒有活動時
- 那麼 (THEN) 工作階段失效

## 移除 (REMOVED) 需求

### 需求：記住我
(已被棄用，改用 2FA。使用者應在每次工作階段重新驗證。)
```

### 差異章節

| 章節                      | 意義         | 封存時會發生什麼 |
| ------------------------- | ------------ | ---------------- |
| `## 新增 (ADDED) 需求`    | 新行為       | 附加到主規格末尾 |
| `## 修改 (MODIFIED) 需求` | 已變更的行為 | 替換現有需求     |
| `## 移除 (REMOVED) 需求`  | 已棄用的行為 | 從主規格中刪除   |

### 為什麼使用差異而不是完整規格

**清晰度。** 差異精確顯示正在變更的內容。閱讀完整規格，您必須在腦海中將其與目前版本進行比對。

**避免衝突。** 兩個變更可以觸及同一個規格檔案而不會衝突，只要它們修改的是不同的需求。

**檢閱效率。** 檢閱者看到的是變更，而不是未更改的內容背景。專注於重要的事物。

**契合既有專案。** 大多數工作都是修改現有行為。差異使修改成為一等公民，而不是事後的想法。

## Schema

Schema 定義了工作流程的成品類型及其相依性。

### Schema 如何運作

```yaml
# openspec/schemas/spec-driven/schema.yaml
name: spec-driven
artifacts:
  - id: proposal
    generates: proposal.md
    requires: []              # 無相依性，可以先建立

  - id: specs
    generates: specs/**/*.md
    requires: [proposal]      # 建立前需要提案

  - id: design
    generates: design.md
    requires: [proposal]      # 可以與規格平行建立

  - id: tasks
    generates: tasks.md
    requires: [specs, design] # 建立前需要規格和設計
```

**成品形成一個相依圖：**

```
                    proposal
                   (根節點)
                       │
         ┌─────────────┴─────────────┐
         │                           │
         ▼                           ▼
      specs                       design
    (需要：                     (需要：
     proposal)                   proposal)
         │                           │
         └─────────────┬─────────────┘
                       │
                       ▼
                    tasks
                (需要：
                specs, design)
```

**相依性是推動因素，而非門檻。** 它們顯示可以建立什麼，而不是您接下來必須建立什麼。如果您不需要設計，可以跳過它。您可以在設計之前或之後建立規格 — 兩者都僅相依於提案。

### 內建 Schema

**spec-driven** (預設)

規格驅動開發的標準工作流程：

```
提案 ──► 規格 ──► 設計 ──► 任務 ──► 實作
```

最適合：大多數需要先就規格達成一致再進行實作的功能開發。

### 自訂 Schema

為您的團隊工作流程建立自訂 schema：

```bash
# 從頭開始建立
openspec schema init research-first

# 或分支現有的 schema
openspec schema fork spec-driven research-first
```

**範例自訂 schema：**

```yaml
# openspec/schemas/research-first/schema.yaml
name: research-first
artifacts:
  - id: research
    generates: research.md
    requires: []           # 先進行研究

  - id: proposal
    generates: proposal.md
    requires: [research]   # 提案根據研究結果擬定

  - id: tasks
    generates: tasks.md
    requires: [proposal]   # 跳過規格/設計，直接進入任務
```

請參閱 [自訂](customization.md) 以瞭解建立和使用自訂 schema 的完整詳細資訊。

## 封存 (Archive)

封存透過將變更的差異規格合併到主規格中並保留變更歷史記錄來完成變更。

### 封存時會發生什麼

```
封存前：

openspec/
├── specs/
│   └── auth/
│       └── spec.md ◄────────────────┐
└── changes/                         │
    └── add-2fa/                     │
        ├── proposal.md              │
        ├── design.md                │ 合併
        ├── tasks.md                 │
        └── specs/                   │
            └── auth/                │
                └── spec.md ─────────┘


封存後：

openspec/
├── specs/
│   └── auth/
│       └── spec.md        # 現在包含 2FA 需求
└── changes/
    └── archive/
        └── 2025-01-24-add-2fa/    # 保留歷史記錄
            ├── proposal.md
            ├── design.md
            ├── tasks.md
            └── specs/
                └── auth/
                    └── spec.md
```

### 封存程序

1. **合併差異。** 每個差異規格章節 (ADDED/MODIFIED/REMOVED) 都套用到對應的主規格。

2. **移動到封存。** 變更資料夾移動到 `changes/archive/`，並帶有日期前綴以按時間順序排列。

3. **保留背景內容。** 所有成品在封存中保持不變。您可以隨時回頭查看以瞭解為什麼要進行變更。

### 為什麼封存很重要

**乾淨的狀態。** 作用中的變更 (`changes/`) 僅顯示進行中的工作。完成的工作會被移開。

**稽核追蹤。** 封存保留了每個變更的完整背景內容 — 不僅僅是更改了什麼，還有說明為什麼的提案、說明如何做的設計，以及顯示已完成工作的任務。

**規格演進。** 規格隨著變更的封存而有機地增長。每次封存都會合併其差異，隨著時間的推移建立起一份全面的規格。

## 一切如何整合在一起

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              OPENSPEC 流程                                   │
│                                                                              │
│   ┌────────────────┐                                                         │
│   │  1. 開始        │  /opsx:new 建立變更資料夾                                 │
│   │     變更        │                                                         │
│   └───────┬────────┘                                                         │
│           │                                                                  │
│           ▼                                                                  │
│   ┌────────────────┐                                                         │
│   │  2. 建立        │  /opsx:ff 或 /opsx:continue                             │
│   │     成品        │  建立提案 → 規格 → 設計 → 任務                             │  
│   │                │  (基於 schema 相依性)                                     │
│   └───────┬────────┘                                                         │
│           │                                                                  │
│           ▼                                                                  │
│   ┌────────────────┐                                                         │
│   │  3. 實作        │  /opsx:apply                                            │
│   │     任務        │  處理任務，將其勾選                                        │
│   │                │◄──── 隨著學習更新成品                                      │
│   └───────┬────────┘                                                         │
│           │                                                                  │
│           ▼                                                                  │
│   ┌────────────────┐                                                         │
│   │  4. 驗證        │  /opsx:verify (選用)                                    │
│   │     工作        │  檢查實作是否符合規格                                      │
│   └───────┬────────┘                                                         │
│           │                                                                  │
│           ▼                                                                  │
│   ┌────────────────┐     ┌──────────────────────────────────────────────┐    │
│   │  5. 封存        │────►│  差異規格合併到主規格中                         │    │
│   │     變更        │     │  變更資料夾移動到 archive/                     │    │
│   └────────────────┘     │  規格現在是更新後的單一事實來源                   │    │
│                          └──────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**良性循環：**

1. 規格描述目前的行為
2. 變更提議修改（作為差異）
3. 實作使變更變為現實
4. 封存將差異合併到規格中
5. 規格現在描述了新的行為
6. 下一個變更在更新後的規格基礎上構建

## 詞彙表

| 術語                               | 定義                                                     |
| ---------------------------------- | -------------------------------------------------------- |
| **成品 (Artifact)**                | 變更中的文件（提案、設計、任務或差異規格）               |
| **封存 (Archive)**                 | 完成變更並將其差異合併到主規格中的過程                   |
| **變更 (Change)**                  | 對系統的提議修改，包裝為包含成品的資料夾                 |
| **差異規格 (Delta spec)**          | 描述相對於目前規格的變更 (ADDED/MODIFIED/REMOVED) 的規格 |
| **領域 (Domain)**                  | 規格的邏輯分組（例如 `auth/`、`payments/`）              |
| **需求 (Requirement)**             | 系統必須具備的特定行為                                   |
| **情境 (Scenario)**                | 需求的具體範例，通常採用 Given/When/Then 格式            |
| **Schema**                         | 成品類型及其相依性的定義                                 |
| **規格 (Spec)**                    | 描述系統行為的規格，包含需求和情境                       |
| **單一事實來源 (Source of truth)** | `openspec/specs/` 目錄，包含目前達成一致的行為           |

## 後續步驟

- [入門指南](getting-started.md) — 實用的第一步
- [工作流程](workflows.md) — 常見模式以及何時使用各個模式
- [指令](commands.md) — 完整的指令參考
- [自訂](customization.md) — 建立自訂 schema 並設定您的專案
